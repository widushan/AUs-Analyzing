<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Browser AU Detector — Rule-based</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; display:flex; gap:20px; padding:20px; }
    .panel { max-width:760px; }
    video, canvas { display:block; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
    #controls { margin-bottom:10px; }
    #info { margin-top:10px; }
    .au-list { max-height:320px; overflow:auto; padding:8px; border-radius:6px; background:#f7f7f7; }
    .au-item { display:flex; justify-content:space-between; padding:4px 6px; border-bottom:1px solid #eee; }
    .au-item:last-child{border-bottom:0;}
    .good { color:green } .low { color:orange } .verylow { color:crimson }
    #countdown { font-size: 48px; font-weight: bold; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff5722; z-index: 10; }
    small.mean-label { color: #555; font-size: 0.8em; margin-left: 4px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <div class="panel">
    <h2>Browser AU Detector</h2>
    <div id="controls">
      <label for="facing">user</label>
      <select id="facing">
        <option value="user">Healthy</option>
        <option value="user">Parkinson</option>
      </select>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <video id="video" autoplay playsinline style="width: 640px; height: 480px;"></video>
    <canvas id="overlay" width="640" height="480" style="position:relative; top:-480px; left:0;"></canvas>
    <div id="countdown"></div>

    <div id="info">
      <small>Green lines show AU measurement points. Labels show AU numbers in real time.</small>
    </div>
  </div>

  <div style="width:320px">
    <h3>AU Values</h3>
    <div class="au-list" id="auList"></div>
    <div style="margin-top:10px;">
      <button id="download">Download CSV</button>
      <button id="downloadSummary">Download Summary CSV</button>
    </div>
  </div>

<script>
(async () => {
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }  // Calculates the Euclidean distance between two points in a 2D plane.
    function meanPoint(pts){ return {x: pts.reduce((s,p)=>s+p.x,0)/pts.length, y: pts.reduce((s,p)=>s+p.y,0)/pts.length}; }  // Calculates the average (mean) coordinates of a set of points in a 2D plane.
    function clampNormalized(x){ if (!isFinite(x)) return 0; return Math.max(0, Math.min(1, x + 0.5)); }  // Normalizes and clamps a value to the range [0, 1] after applying an offset.

    const idx = {
      leftEyeOuter: 33, rightEyeOuter: 263,
      leftUpperEyelid: 159, leftLowerEyelid: 145,
      rightUpperEyelid: 386, rightLowerEyelid: 374,
      leftInnerBrow: 70, leftOuterBrow: 105,
      rightInnerBrow: 300, rightOuterBrow: 334,
      mouthLeft: 61, mouthRight: 291,
      upperLip: 13, lowerLip: 14,
      chinLower: 152, jawPoint: 17,
      noseTip: 1, noseBridge: 6
    };

    function computeAUs(landmarks){
      const L = (i)=>({x: landmarks[i].x, y: landmarks[i].y});    // function to extract the {x, y} coordinates of a landmark at index i from the landmarks array
      const iod = dist(L(idx.leftEyeOuter), L(idx.rightEyeOuter)) || 1;    // Calculates the distance between the outer corners of the eyes

      const au1 = -((L(idx.leftInnerBrow).y - meanPoint([L(idx.leftUpperEyelid), L(idx.leftLowerEyelid)]).y +
                    L(idx.rightInnerBrow).y - meanPoint([L(idx.rightUpperEyelid), L(idx.rightLowerEyelid)]).y) / 2) / iod;    // Quantifies how much the inner eyebrows are raised relative to the eyes.
      const au2 = -((L(idx.leftOuterBrow).y - L(idx.leftUpperEyelid).y +
                    L(idx.rightOuterBrow).y - L(idx.rightUpperEyelid).y) / 2) / iod;    // Captures outer eyebrow elevation, distinct from AU1.
      const au4 = ((L(idx.leftInnerBrow).y + L(idx.rightInnerBrow).y)/2 - 
                  (L(idx.leftUpperEyelid).y + L(idx.rightUpperEyelid).y)/2) / iod;    // Measures downward movement of the eyebrows relative to the eyes.
      const leftGap = L(idx.leftUpperEyelid).y - L(idx.leftLowerEyelid).y;
      const rightGap = L(idx.rightUpperEyelid).y - L(idx.rightLowerEyelid).y;
      const au6 = -( (leftGap + rightGap) / 2 ) / iod;    // Quantifies eye narrowing due to cheek movement.
      const au7 = Math.max(0, au6*1.2);    // Approximates lid tightening based on eye gap reduction.
      const au9 = -(L(idx.noseTip).y - L(idx.upperLip).y) / iod;    // Captures nose wrinkling by reduced nose-to-lip distance.
      const au10 = au9 * 0.9;    // Approximates upper lip movement based on nose wrinkling.
      const mouthWidth = dist(L(idx.mouthLeft), L(idx.mouthRight));
      const au12 = mouthWidth / iod;b   // Quantifies the width of a smile.
      const lipHeight = Math.abs(L(idx.upperLip).y - L(idx.lowerLip).y) || 1e-6;
      const au14 = (mouthWidth / lipHeight) / 10;    // Measures the ratio of mouth width to height, indicating tightened lip corners.
      const mouthMidY = (L(idx.mouthLeft).y + L(idx.mouthRight).y) / 2;
      const au15 = (( (L(idx.mouthLeft).y - mouthMidY) + (L(idx.mouthRight).y - mouthMidY) )/2) / iod;  // Captures downward lip movement (though the formula may simplify, as deviations cancel out if symmetric).
      const au17 = -( (L(idx.lowerLip).y - L(idx.chinLower).y) / iod );    // Quantifies chin upward movement.
      const au20 = mouthWidth / iod;    // Measures horizontal lip stretching, though its redundancy with AU12 suggests possible simplification or context-specific use.
      const au23 = 1 - (lipHeight*2 / iod);    // Quantifies reduced mouth opening.
      const au25 = Math.abs(L(idx.upperLip).y - L(idx.lowerLip).y) / iod;    // Measures the degree of lip parting.
      const au26 = Math.abs(L(idx.jawPoint).y - L(idx.chinLower).y) / iod;    // Quantifies jaw opening.
      const au45 = (leftGap + rightGap) / (2*iod);    // Measures eye closure.

      return { AU1: clampNormalized(au1), AU2: clampNormalized(au2), AU4: clampNormalized(au4),
              AU6: clampNormalized(au6), AU7: clampNormalized(au7), AU9: clampNormalized(au9),
              AU10: clampNormalized(au10), AU12: clampNormalized(au12), AU14: clampNormalized(au14),
              AU15: clampNormalized(au15), AU17: clampNormalized(au17), AU20: clampNormalized(au20),
              AU23: clampNormalized(au23), AU25: clampNormalized(au25), AU26: clampNormalized(au26),
              AU45: clampNormalized(au45), iod: iod };
    }

    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const auListDiv = document.getElementById('auList');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const facing = document.getElementById('facing');
    const downloadBtn = document.getElementById('download');
    const summaryBtn = document.getElementById('downloadSummary');
    const countdownDiv = document.getElementById('countdown');

    let camera = null, faceMesh = null, lastAUs = null, csvRows = [], samplingInterval = null;
    let mediaRecorder, recordedChunks = [];
    let sessionTimestamp = '';
    let auHistory = {};


    // detect facial landmarks from a video feed
    faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);


    // draws a line between two facial landmarks on the canvas (overlay) and adds a text label at the midpoint.
    function drawLine(i, j, landmarks, label) {
      ctx.beginPath();
      ctx.moveTo(landmarks[i].x * overlay.width, landmarks[i].y * overlay.height);
      ctx.lineTo(landmarks[j].x * overlay.width, landmarks[j].y * overlay.height);
      ctx.strokeStyle = "lime";
      ctx.lineWidth = 2;
      ctx.stroke();
      const midX = (landmarks[i].x + landmarks[j].x) / 2 * overlay.width;
      const midY = (landmarks[i].y + landmarks[j].y) / 2 * overlay.height;
      ctx.fillStyle = "black";
      ctx.font = "14px Arial";
      ctx.fillText(label, midX + 4, midY - 4);
    }



    // processing loop for the AU detector, handling faceMesh results to compute AU values, draw visualizations on overlay, and update auListDiv.
    function onResults(results){
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      ctx.clearRect(0,0,overlay.width, overlay.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        ctx.fillStyle = "orange";
        ctx.fillText("No face detected", 10, 20);
        return;
      }
      const lm = results.multiFaceLandmarks[0];
      lastAUs = computeAUs(lm);

      // Green lines for all AUs
      drawLine(idx.leftInnerBrow, idx.leftUpperEyelid, lm, "AU1(L)");
      drawLine(idx.rightInnerBrow, idx.rightUpperEyelid, lm, "AU1(R)");
      drawLine(idx.leftOuterBrow, idx.leftUpperEyelid, lm, "AU2(L)");
      drawLine(idx.rightOuterBrow, idx.rightUpperEyelid, lm, "AU2(R)");
      drawLine(idx.leftInnerBrow, idx.leftLowerEyelid, lm, "AU4(L)");
      drawLine(idx.rightInnerBrow, idx.rightLowerEyelid, lm, "AU4(R)");
      drawLine(idx.leftUpperEyelid, idx.leftLowerEyelid, lm, "AU6(L)");
      drawLine(idx.rightUpperEyelid, idx.rightLowerEyelid, lm, "AU6(R)");
      drawLine(idx.leftLowerEyelid, idx.leftUpperEyelid, lm, "AU7(L)");
      drawLine(idx.rightLowerEyelid, idx.rightUpperEyelid, lm, "AU7(R)");
      drawLine(idx.noseTip, idx.upperLip, lm, "AU9");
      drawLine(idx.noseBridge, idx.upperLip, lm, "AU10");
      drawLine(idx.mouthLeft, idx.noseTip, lm, "AU12(L)");
      drawLine(idx.mouthRight, idx.noseTip, lm, "AU12(R)");
      drawLine(idx.mouthLeft, idx.upperLip, lm, "AU14(L)");
      drawLine(idx.mouthRight, idx.upperLip, lm, "AU14(R)");
      drawLine(idx.mouthLeft, idx.lowerLip, lm, "AU15(L)");
      drawLine(idx.mouthRight, idx.lowerLip, lm, "AU15(R)");
      drawLine(idx.lowerLip, idx.chinLower, lm, "AU17");
      drawLine(idx.mouthLeft, idx.mouthRight, lm, "AU20");
      drawLine(idx.upperLip, idx.lowerLip, lm, "AU23/25");
      drawLine(idx.jawPoint, idx.chinLower, lm, "AU26");
      drawLine(idx.leftUpperEyelid, idx.leftLowerEyelid, lm, "AU45(L)");
      drawLine(idx.rightUpperEyelid, idx.rightLowerEyelid, lm, "AU45(R)");

      renderAUList(lastAUs);
    }



    // updates the auListDiv to display current and mean AU intensities in a styled, user-friendly format, complementing the overlay canvas’s visualizations.
    function renderAUList(aus){
      const order = ['AU1','AU2','AU4','AU6','AU7','AU9','AU10','AU12','AU14','AU15','AU17','AU20','AU23','AU25','AU26','AU45'];
      auListDiv.innerHTML = '';
      order.forEach(k=>{
        const val = aus[k]||0;
        const meanVal = auHistory[k]?.length ? computeMean(auHistory[k]) : 0;
        const item = document.createElement('div');
        item.className = 'au-item';
        const name = document.createElement('div'); name.textContent = k;
        const v = document.createElement('div'); 
        v.innerHTML = `${val.toFixed(2)} <small class="mean-label">(avg: ${meanVal.toFixed(2)})</small>`;
        if (val > 0.6) v.className = 'good';
        else if (val > 0.3) v.className = 'low';
        else v.className = 'verylow';
        item.appendChild(name); item.appendChild(v);
        auListDiv.appendChild(item);
      });
    }



    // statistical functions (computeMean, computeStd, computeMin, computeMax, computeMedian, computeSkewness, computeKurtosis) analyze AU intensities in auHistory, supporting real-time display in auListDiv (via computeMean) and summary CSV export (via all functions)
    function computeMean(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }   // Calculates the arithmetic mean (average) of an array of numbers.
    function computeStd(arr){ if(arr.length<2) return 0; const m=computeMean(arr); return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-m,2),0)/(arr.length-1)); }    // Calculates the sample standard deviation of an array, measuring data spread.
    function computeMin(arr){ return arr.length ? Math.min(...arr) : 0; }  // Finds the minimum value in an array.
    function computeMax(arr){ return arr.length ? Math.max(...arr) : 0; }  // Finds the maximum value in an array.
    function computeMedian(arr){ if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length/2); return s.length%2? s[m] : (s[m-1]+s[m])/2; }  // Calculates the median (middle value) of an array.
    function computeSkewness(arr){ if(arr.length<2) return 0; const m=computeMean(arr), s=computeStd(arr); if(s===0) return 0; const n=arr.length; return arr.reduce((a,b)=>a+Math.pow(b-m,3),0)/n/Math.pow(s,3); }  // Calculates the skewness of an array, measuring the asymmetry of the data distribution.
    function computeKurtosis(arr){ if(arr.length<2) return 0; const m=computeMean(arr), s=computeStd(arr); if(s===0) return 0; const n=arr.length; return arr.reduce((a,b)=>a+Math.pow(b-m,4),0)/n/Math.pow(s,4)-3; }  // Calculates the excess kurtosis, measuring the “tailedness” of the data distribution.


    // The startBtn.onclick function initiates the AU detection process with a 3-second countdown, manages button states, and triggers startRecording.
    startBtn.onclick = function() {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      let count = 3;
      countdownDiv.textContent = count;
      const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) countdownDiv.textContent = count;
        else if (count === 0) countdownDiv.textContent = "Start!";
        else { clearInterval(countdownInterval); countdownDiv.textContent = ""; startRecording(); }
      }, 1000);
    };


    // The startRecording function sets up the video stream, initializes the MediaRecorder, and starts capturing frames for AU detection.
    async function startRecording() {
      sessionTimestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const constraints = { video: { width: 640, height: 480, facingMode: facing.value }, audio: true };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      video.muted = true; await video.play();

      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `session_${sessionTimestamp}.webm`; a.click();
        URL.revokeObjectURL(url);
      };
      mediaRecorder.start();

      camera = new Camera(video, { onFrame: async () => { await faceMesh.send({image: video}); }, width: 640, height: 480 });
      camera.start();

      const auOrder = ['timestamp','AU1','AU2','AU4','AU6','AU7','AU9','AU10','AU12','AU14','AU15','AU17','AU20','AU23','AU25','AU26','AU45','iod'];
      csvRows = [auOrder.join(',')];
      auHistory = {}; auOrder.slice(1).forEach(k => { auHistory[k] = []; });

      samplingInterval = setInterval(()=> {
        if (lastAUs){
          auOrder.slice(1).forEach(k => auHistory[k].push(lastAUs[k] ?? 0));
          csvRows.push([ new Date().toISOString(), ...auOrder.slice(1).map(k => lastAUs[k]?.toFixed(3) ?? '0.000') ].join(','));
        }
      }, 500);
    }


    // The stopBtn.onclick function stops the camera, MediaRecorder, and sampling interval, resets the video stream, and updates button states.
    stopBtn.onclick = () => {
      if (camera) camera.stop();
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      if (samplingInterval) clearInterval(samplingInterval);
      if (video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); video.srcObject = null; }
      startBtn.disabled = false; stopBtn.disabled = true;
    };



    // The downloadBtn.onclick function generates a CSV file from the recorded AU data and triggers a download.
    downloadBtn.onclick = () => {
      if (csvRows.length > 1) {
        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `au_data_${sessionTimestamp}.csv`; a.click();
        URL.revokeObjectURL(url);
      }
    };


    // The summaryBtn.onclick function generates a summary CSV file from the recorded AU data, calculating mean, std, min, max, median, skewness, and kurtosis for each AU.
    summaryBtn.onclick = () => {
      const summaryRows = ["AU,Mean,Std,Min,Max,Median,Skewness,Kurtosis"];
      Object.keys(auHistory).forEach(au => {
        const vals = auHistory[au];
        summaryRows.push([
          au,
          computeMean(vals).toFixed(4),
          computeStd(vals).toFixed(4),
          computeMin(vals).toFixed(4),
          computeMax(vals).toFixed(4),
          computeMedian(vals).toFixed(4),
          computeSkewness(vals).toFixed(4),
          computeKurtosis(vals).toFixed(4)
        ].join(","));
      });
      const blob = new Blob([summaryRows.join("\n")], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = `au_summary_${sessionTimestamp}.csv`; a.click();
      URL.revokeObjectURL(url);
    };
  }
)();
</script>
</body>
</html>
